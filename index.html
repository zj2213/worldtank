<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>坦克大战 - 网页/手机通用版</title>
    <style>
        body { background: #1a1a1a; display: flex; flex-direction: column; align-items: center; margin: 0; font-family: sans-serif; color: #fff; touch-action: none; -webkit-user-select: none; }
        #game-container { position: relative; margin-top: 10px; border: 4px solid #444; background: #000; }
        canvas { display: block; max-width: 100vw; max-height: 70vh; image-rendering: pixelated; }
        
        /* 移动端控制面板 */
        #controls { display: grid; grid-template-columns: 1fr 1fr; width: 100%; max-width: 520px; padding: 20px; box-sizing: border-box; }
        .d-pad { display: grid; grid-template-columns: repeat(3, 60px); grid-template-rows: repeat(3, 60px); gap: 5px; }
        .btn { background: rgba(255,255,255,0.2); border: 2px solid #666; border-radius: 10px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 20px; color: white; -webkit-tap-highlight-color: transparent; }
        .btn:active { background: rgba(255,255,255,0.5); }
        .fire-zone { display: flex; align-items: center; justify-content: center; }
        .btn-fire { width: 100px; height: 100px; border-radius: 50%; background: rgba(255, 0, 0, 0.4); font-size: 24px; border: 3px solid #f00; }
        
        /* UI显示 */
        .ui-header { display: flex; gap: 20px; margin-top: 10px; font-size: 14px; background: #333; padding: 5px 15px; border-radius: 20px; }
        #message { position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.9); padding: 20px; text-align: center; border: 1px solid #fff; display: none; z-index: 10; }
    </style>
</head>
<body>
    <div class="ui-header">
        <span>关卡: <b id="level">1</b></span>
        <span>得分: <b id="score">0</b></span>
    </div>

    <div id="game-container">
        <canvas id="gameCanvas" width="520" height="520"></canvas>
        <div id="message"></div>
    </div>

    <div id="controls">
        <div class="d-pad">
            <div></div><div class="btn" id="btn-w">↑</div><div></div>
            <div class="btn" id="btn-a">←</div><div></div><div class="btn" id="btn-d">→</div>
            <div></div><div class="btn" id="btn-s">↓</div><div></div>
        </div>
        <div class="fire-zone">
            <div class="btn btn-fire" id="btn-j">FIRE</div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const TILE_SIZE = 40;
        
        let gameState = { level: 1, score: 0, active: true, enemies: [], bullets: [], map: [] };
        const LEVELS = [
            [[0,0,0,0,0,0,0,0,0,0,0,0,0],[0,1,0,1,0,1,0,1,0,1,0,1,0],[0,1,0,1,0,0,0,0,0,1,0,1,0],[0,1,0,1,0,1,1,1,0,1,0,1,0],[0,0,0,0,0,0,0,0,0,0,0,0,0],[1,1,0,1,1,0,0,0,1,1,0,1,1],[0,0,0,0,0,0,0,0,0,0,0,0,0],[0,1,1,1,0,1,1,1,0,1,1,1,0],[0,0,0,0,0,1,0,1,0,0,0,0,0],[1,0,1,1,0,0,0,0,0,1,1,0,1],[0,0,0,0,0,1,1,1,0,0,0,0,0],[0,1,1,0,0,1,2,1,0,0,1,1,0],[0,0,0,0,0,1,0,1,0,0,0,0,0]],
            [[0,0,0,0,0,0,0,0,0,0,0,0,0],[1,1,0,1,1,0,1,0,1,1,0,1,1],[1,1,0,1,1,0,1,0,1,1,0,1,1],[0,0,0,0,0,0,0,0,0,0,0,0,0],[1,1,0,1,1,1,1,1,1,1,0,1,1],[0,0,0,0,0,0,0,0,0,0,0,0,0],[1,1,0,1,0,1,0,1,0,1,0,1,1],[0,0,0,1,0,1,0,1,0,1,0,0,0],[1,1,0,0,0,0,0,0,0,0,0,1,1],[0,0,0,1,1,1,1,1,1,1,0,0,0],[1,0,0,0,0,0,0,0,0,0,0,0,1],[1,1,1,0,0,1,2,1,0,0,1,1,1],[0,0,0,0,0,1,0,1,0,0,0,0,0]]
        ];

        class Bullet {
            constructor(x, y, dir, isPlayer) {
                this.x = x; this.y = y; this.dir = dir; this.isPlayer = isPlayer;
                this.speed = isPlayer ? 7 : 3.5; this.active = true;
            }
            update() {
                if(this.dir==='U') this.y-=this.speed; if(this.dir==='D') this.y+=this.speed;
                if(this.dir==='L') this.x-=this.speed; if(this.dir==='R') this.x+=this.speed;
                let tx = Math.floor(this.x/TILE_SIZE), ty = Math.floor(this.y/TILE_SIZE);
                if(ty<0||ty>12||tx<0||tx>12) { this.active=false; return; }
                if(gameState.map[ty][tx] === 1) { gameState.map[ty][tx] = 0; this.active = false; }
                else if(gameState.map[ty][tx] === 2) { gameOver("基地沦陷！"); }
            }
            draw() { ctx.fillStyle = this.isPlayer ? "#0ff" : "#f44"; ctx.beginPath(); ctx.arc(this.x, this.y, 4, 0, Math.PI*2); ctx.fill(); }
        }

        class Tank {
            constructor(x, y, color, isPlayer = false) {
                this.x = x; this.y = y; this.color = color; this.isPlayer = isPlayer;
                this.dir = 'U'; this.speed = isPlayer ? 3 : 1.8; this.timer = 0; this.fireCooldown = 0;
            }
            reset(x, y) { this.x = x; this.y = y; this.dir = 'U'; }
            move(newDir) {
                this.dir = newDir;
                let nx = this.x, ny = this.y;
                if(this.dir==='U') ny-=this.speed; if(this.dir==='D') ny+=this.speed;
                if(this.dir==='L') nx-=this.speed; if(this.dir==='R') nx+=this.speed;
                if(this.checkCollision(nx, ny)) { this.x = nx; this.y = ny; return true; }
                return false;
            }
            checkCollision(nx, ny) {
                if(nx<0 || nx>canvas.width-TILE_SIZE || ny<0 || ny>canvas.height-TILE_SIZE) return false;
                const offset = 6;
                const pts = [[nx+offset,ny+offset], [nx+TILE_SIZE-offset,ny+offset], [nx+offset,ny+TILE_SIZE-offset], [nx+TILE_SIZE-offset,ny+TILE_SIZE-offset]];
                for(let p of pts) {
                    let mx = Math.floor(p[0]/TILE_SIZE), my = Math.floor(p[1]/TILE_SIZE);
                    if(gameState.map[my] && gameState.map[my][mx] !== 0) return false;
                }
                return true;
            }
            shoot() {
                if(this.fireCooldown > 0) return;
                gameState.bullets.push(new Bullet(this.x + TILE_SIZE/2, this.y + TILE_SIZE/2, this.dir, this.isPlayer));
                this.fireCooldown = this.isPlayer ? 25 : (50 + Math.random()*50);
            }
            draw() {
                ctx.save();
                ctx.translate(this.x + TILE_SIZE/2, this.y + TILE_SIZE/2);
                ctx.rotate({U:0, D:Math.PI, L:-Math.PI/2, R:Math.PI/2}[this.dir]);
                ctx.fillStyle = this.color; ctx.fillRect(-16, -16, 32, 32);
                ctx.fillStyle = "#333"; ctx.fillRect(-18, -18, 8, 36); ctx.fillRect(10, -18, 8, 36);
                ctx.fillStyle = "#fff"; ctx.fillRect(-8, -8, 16, 16); ctx.fillRect(-2, -22, 4, 18);
                ctx.restore();
            }
        }

        const player = new Tank(4*TILE_SIZE, 12*TILE_SIZE, '#ffcc00', true);
        const keys = {};

        // --- 触屏控制绑定 ---
        const bindBtn = (id, key) => {
            const btn = document.getElementById(id);
            const start = (e) => { e.preventDefault(); keys[key] = true; if(key==='j') player.shoot(); };
            const end = (e) => { e.preventDefault(); keys[key] = false; };
            btn.addEventListener('touchstart', start); btn.addEventListener('touchend', end);
            btn.addEventListener('mousedown', start); btn.addEventListener('mouseup', end);
        };
        ['w','a','s','d','j'].forEach(k => bindBtn('btn-'+k, k));

        window.onkeydown = e => { keys[e.key.toLowerCase()] = true; if(e.key==='j') player.shoot(); };
        window.onkeyup = e => keys[e.key.toLowerCase()] = false;

        function initLevel(lvl) {
            gameState.bullets = [];
            gameState.map = LEVELS[(lvl-1) % LEVELS.length].map(row => [...row]);
            player.reset(4*TILE_SIZE, 12*TILE_SIZE);
            gameState.enemies = [];
            for(let i=0; i < (2 + lvl); i++) gameState.enemies.push(new Tank((i%3)*5*TILE_SIZE, 0, '#f44'));
            document.getElementById('level').innerText = lvl;
            showMsg("Level " + lvl, 1500);
        }

        function showMsg(txt, time) {
            const el = document.getElementById('message');
            el.innerHTML = txt; el.style.display = 'block';
            if(time) setTimeout(() => el.style.display = 'none', time);
        }

        function gameOver(txt) {
            gameState.active = false;
            showMsg(txt + "<br>点击屏幕重启", null);
            canvas.onclick = () => location.reload();
        }

        function update() {
            if(!gameState.active) return;
            if(keys['w']) player.move('U'); else if(keys['s']) player.move('D');
            else if(keys['a']) player.move('L'); else if(keys['d']) player.move('R');
            if(player.fireCooldown > 0) player.fireCooldown--;

            gameState.enemies.forEach(en => {
                if(en.timer-- <= 0) { en.dir = ['U','D','L','R'][Math.floor(Math.random()*4)]; en.timer = 40 + Math.random()*80; }
                en.move(en.dir);
                if(Math.random() < 0.015) en.shoot();
                if(en.fireCooldown > 0) en.fireCooldown--;
            });

            gameState.bullets.forEach((b, i) => {
                b.update();
                if(!b.active) { gameState.bullets.splice(i, 1); return; }
                if(b.isPlayer) {
                    gameState.enemies.forEach((en, ei) => {
                        if(b.x > en.x && b.x < en.x+TILE_SIZE && b.y > en.y && b.y < en.y+TILE_SIZE) {
                            gameState.enemies.splice(ei, 1); b.active = false; gameState.score += 100;
                        }
                    });
                } else if(b.x > player.x && b.x < player.x+TILE_SIZE && b.y > player.y && b.y < player.y+TILE_SIZE) {
                    gameOver("你被击毁了！");
                }
            });

            if(gameState.enemies.length === 0) { gameState.level++; initLevel(gameState.level); }
            document.getElementById('score').innerText = gameState.score;
        }

        function draw() {
            ctx.fillStyle = "#000"; ctx.fillRect(0,0,canvas.width,canvas.height);
            gameState.map.forEach((row, r) => {
                row.forEach((cell, c) => {
                    if(cell===1) { ctx.fillStyle = '#8b4513'; ctx.fillRect(c*TILE_SIZE+2, r*TILE_SIZE+2, TILE_SIZE-4, TILE_SIZE-4); }
                    else if(cell===2) { ctx.fillStyle = '#ffd700'; ctx.fillRect(c*TILE_SIZE, r*TILE_SIZE, TILE_SIZE, TILE_SIZE); }
                });
            });
            player.draw();
            gameState.enemies.forEach(en => en.draw());
            gameState.bullets.forEach(b => b.draw());
            requestAnimationFrame(() => { update(); draw(); });
        }

        initLevel(1);
        draw();
    </script>
</body>
</html>